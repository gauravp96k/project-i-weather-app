{"ast":null,"code":"(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) : typeof define === 'function' && define.amd ? define(['exports'], factory) : (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.sourcemapCodec = {}));\n})(this, function (exports) {\n  'use strict';\n\n  const comma = ','.charCodeAt(0);\n  const semicolon = ';'.charCodeAt(0);\n  const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n  const intToChar = new Uint8Array(64); // 64 possible chars.\n  const charToInt = new Uint8Array(128); // z is 122 in ASCII\n  for (let i = 0; i < chars.length; i++) {\n    const c = chars.charCodeAt(i);\n    intToChar[i] = c;\n    charToInt[c] = i;\n  }\n  function decodeInteger(reader, relative) {\n    let value = 0;\n    let shift = 0;\n    let integer = 0;\n    do {\n      const c = reader.next();\n      integer = charToInt[c];\n      value |= (integer & 31) << shift;\n      shift += 5;\n    } while (integer & 32);\n    const shouldNegate = value & 1;\n    value >>>= 1;\n    if (shouldNegate) {\n      value = -0x80000000 | -value;\n    }\n    return relative + value;\n  }\n  function encodeInteger(builder, num, relative) {\n    let delta = num - relative;\n    delta = delta < 0 ? -delta << 1 | 1 : delta << 1;\n    do {\n      let clamped = delta & 0b011111;\n      delta >>>= 5;\n      if (delta > 0) clamped |= 0b100000;\n      builder.write(intToChar[clamped]);\n    } while (delta > 0);\n    return num;\n  }\n  function hasMoreVlq(reader, max) {\n    if (reader.pos >= max) return false;\n    return reader.peek() !== comma;\n  }\n  const bufLength = 1024 * 16;\n  // Provide a fallback for older environments.\n  const td = typeof TextDecoder !== 'undefined' ? /* #__PURE__ */new TextDecoder() : typeof Buffer !== 'undefined' ? {\n    decode(buf) {\n      const out = Buffer.from(buf.buffer, buf.byteOffset, buf.byteLength);\n      return out.toString();\n    }\n  } : {\n    decode(buf) {\n      let out = '';\n      for (let i = 0; i < buf.length; i++) {\n        out += String.fromCharCode(buf[i]);\n      }\n      return out;\n    }\n  };\n  class StringWriter {\n    constructor() {\n      this.pos = 0;\n      this.out = '';\n      this.buffer = new Uint8Array(bufLength);\n    }\n    write(v) {\n      const {\n        buffer\n      } = this;\n      buffer[this.pos++] = v;\n      if (this.pos === bufLength) {\n        this.out += td.decode(buffer);\n        this.pos = 0;\n      }\n    }\n    flush() {\n      const {\n        buffer,\n        out,\n        pos\n      } = this;\n      return pos > 0 ? out + td.decode(buffer.subarray(0, pos)) : out;\n    }\n  }\n  class StringReader {\n    constructor(buffer) {\n      this.pos = 0;\n      this.buffer = buffer;\n    }\n    next() {\n      return this.buffer.charCodeAt(this.pos++);\n    }\n    peek() {\n      return this.buffer.charCodeAt(this.pos);\n    }\n    indexOf(char) {\n      const {\n        buffer,\n        pos\n      } = this;\n      const idx = buffer.indexOf(char, pos);\n      return idx === -1 ? buffer.length : idx;\n    }\n  }\n  const EMPTY = [];\n  function decodeOriginalScopes(input) {\n    const {\n      length\n    } = input;\n    const reader = new StringReader(input);\n    const scopes = [];\n    const stack = [];\n    let line = 0;\n    for (; reader.pos < length; reader.pos++) {\n      line = decodeInteger(reader, line);\n      const column = decodeInteger(reader, 0);\n      if (!hasMoreVlq(reader, length)) {\n        const last = stack.pop();\n        last[2] = line;\n        last[3] = column;\n        continue;\n      }\n      const kind = decodeInteger(reader, 0);\n      const fields = decodeInteger(reader, 0);\n      const hasName = fields & 0b0001;\n      const scope = hasName ? [line, column, 0, 0, kind, decodeInteger(reader, 0)] : [line, column, 0, 0, kind];\n      let vars = EMPTY;\n      if (hasMoreVlq(reader, length)) {\n        vars = [];\n        do {\n          const varsIndex = decodeInteger(reader, 0);\n          vars.push(varsIndex);\n        } while (hasMoreVlq(reader, length));\n      }\n      scope.vars = vars;\n      scopes.push(scope);\n      stack.push(scope);\n    }\n    return scopes;\n  }\n  function encodeOriginalScopes(scopes) {\n    const writer = new StringWriter();\n    for (let i = 0; i < scopes.length;) {\n      i = _encodeOriginalScopes(scopes, i, writer, [0]);\n    }\n    return writer.flush();\n  }\n  function _encodeOriginalScopes(scopes, index, writer, state) {\n    const scope = scopes[index];\n    const {\n      0: startLine,\n      1: startColumn,\n      2: endLine,\n      3: endColumn,\n      4: kind,\n      vars\n    } = scope;\n    if (index > 0) writer.write(comma);\n    state[0] = encodeInteger(writer, startLine, state[0]);\n    encodeInteger(writer, startColumn, 0);\n    encodeInteger(writer, kind, 0);\n    const fields = scope.length === 6 ? 0b0001 : 0;\n    encodeInteger(writer, fields, 0);\n    if (scope.length === 6) encodeInteger(writer, scope[5], 0);\n    for (const v of vars) {\n      encodeInteger(writer, v, 0);\n    }\n    for (index++; index < scopes.length;) {\n      const next = scopes[index];\n      const {\n        0: l,\n        1: c\n      } = next;\n      if (l > endLine || l === endLine && c >= endColumn) {\n        break;\n      }\n      index = _encodeOriginalScopes(scopes, index, writer, state);\n    }\n    writer.write(comma);\n    state[0] = encodeInteger(writer, endLine, state[0]);\n    encodeInteger(writer, endColumn, 0);\n    return index;\n  }\n  function decodeGeneratedRanges(input) {\n    const {\n      length\n    } = input;\n    const reader = new StringReader(input);\n    const ranges = [];\n    const stack = [];\n    let genLine = 0;\n    let definitionSourcesIndex = 0;\n    let definitionScopeIndex = 0;\n    let callsiteSourcesIndex = 0;\n    let callsiteLine = 0;\n    let callsiteColumn = 0;\n    let bindingLine = 0;\n    let bindingColumn = 0;\n    do {\n      const semi = reader.indexOf(';');\n      let genColumn = 0;\n      for (; reader.pos < semi; reader.pos++) {\n        genColumn = decodeInteger(reader, genColumn);\n        if (!hasMoreVlq(reader, semi)) {\n          const last = stack.pop();\n          last[2] = genLine;\n          last[3] = genColumn;\n          continue;\n        }\n        const fields = decodeInteger(reader, 0);\n        const hasDefinition = fields & 0b0001;\n        const hasCallsite = fields & 0b0010;\n        const hasScope = fields & 0b0100;\n        let callsite = null;\n        let bindings = EMPTY;\n        let range;\n        if (hasDefinition) {\n          const defSourcesIndex = decodeInteger(reader, definitionSourcesIndex);\n          definitionScopeIndex = decodeInteger(reader, definitionSourcesIndex === defSourcesIndex ? definitionScopeIndex : 0);\n          definitionSourcesIndex = defSourcesIndex;\n          range = [genLine, genColumn, 0, 0, defSourcesIndex, definitionScopeIndex];\n        } else {\n          range = [genLine, genColumn, 0, 0];\n        }\n        range.isScope = !!hasScope;\n        if (hasCallsite) {\n          const prevCsi = callsiteSourcesIndex;\n          const prevLine = callsiteLine;\n          callsiteSourcesIndex = decodeInteger(reader, callsiteSourcesIndex);\n          const sameSource = prevCsi === callsiteSourcesIndex;\n          callsiteLine = decodeInteger(reader, sameSource ? callsiteLine : 0);\n          callsiteColumn = decodeInteger(reader, sameSource && prevLine === callsiteLine ? callsiteColumn : 0);\n          callsite = [callsiteSourcesIndex, callsiteLine, callsiteColumn];\n        }\n        range.callsite = callsite;\n        if (hasMoreVlq(reader, semi)) {\n          bindings = [];\n          do {\n            bindingLine = genLine;\n            bindingColumn = genColumn;\n            const expressionsCount = decodeInteger(reader, 0);\n            let expressionRanges;\n            if (expressionsCount < -1) {\n              expressionRanges = [[decodeInteger(reader, 0)]];\n              for (let i = -1; i > expressionsCount; i--) {\n                const prevBl = bindingLine;\n                bindingLine = decodeInteger(reader, bindingLine);\n                bindingColumn = decodeInteger(reader, bindingLine === prevBl ? bindingColumn : 0);\n                const expression = decodeInteger(reader, 0);\n                expressionRanges.push([expression, bindingLine, bindingColumn]);\n              }\n            } else {\n              expressionRanges = [[expressionsCount]];\n            }\n            bindings.push(expressionRanges);\n          } while (hasMoreVlq(reader, semi));\n        }\n        range.bindings = bindings;\n        ranges.push(range);\n        stack.push(range);\n      }\n      genLine++;\n      reader.pos = semi + 1;\n    } while (reader.pos < length);\n    return ranges;\n  }\n  function encodeGeneratedRanges(ranges) {\n    if (ranges.length === 0) return '';\n    const writer = new StringWriter();\n    for (let i = 0; i < ranges.length;) {\n      i = _encodeGeneratedRanges(ranges, i, writer, [0, 0, 0, 0, 0, 0, 0]);\n    }\n    return writer.flush();\n  }\n  function _encodeGeneratedRanges(ranges, index, writer, state) {\n    const range = ranges[index];\n    const {\n      0: startLine,\n      1: startColumn,\n      2: endLine,\n      3: endColumn,\n      isScope,\n      callsite,\n      bindings\n    } = range;\n    if (state[0] < startLine) {\n      catchupLine(writer, state[0], startLine);\n      state[0] = startLine;\n      state[1] = 0;\n    } else if (index > 0) {\n      writer.write(comma);\n    }\n    state[1] = encodeInteger(writer, range[1], state[1]);\n    const fields = (range.length === 6 ? 0b0001 : 0) | (callsite ? 0b0010 : 0) | (isScope ? 0b0100 : 0);\n    encodeInteger(writer, fields, 0);\n    if (range.length === 6) {\n      const {\n        4: sourcesIndex,\n        5: scopesIndex\n      } = range;\n      if (sourcesIndex !== state[2]) {\n        state[3] = 0;\n      }\n      state[2] = encodeInteger(writer, sourcesIndex, state[2]);\n      state[3] = encodeInteger(writer, scopesIndex, state[3]);\n    }\n    if (callsite) {\n      const {\n        0: sourcesIndex,\n        1: callLine,\n        2: callColumn\n      } = range.callsite;\n      if (sourcesIndex !== state[4]) {\n        state[5] = 0;\n        state[6] = 0;\n      } else if (callLine !== state[5]) {\n        state[6] = 0;\n      }\n      state[4] = encodeInteger(writer, sourcesIndex, state[4]);\n      state[5] = encodeInteger(writer, callLine, state[5]);\n      state[6] = encodeInteger(writer, callColumn, state[6]);\n    }\n    if (bindings) {\n      for (const binding of bindings) {\n        if (binding.length > 1) encodeInteger(writer, -binding.length, 0);\n        const expression = binding[0][0];\n        encodeInteger(writer, expression, 0);\n        let bindingStartLine = startLine;\n        let bindingStartColumn = startColumn;\n        for (let i = 1; i < binding.length; i++) {\n          const expRange = binding[i];\n          bindingStartLine = encodeInteger(writer, expRange[1], bindingStartLine);\n          bindingStartColumn = encodeInteger(writer, expRange[2], bindingStartColumn);\n          encodeInteger(writer, expRange[0], 0);\n        }\n      }\n    }\n    for (index++; index < ranges.length;) {\n      const next = ranges[index];\n      const {\n        0: l,\n        1: c\n      } = next;\n      if (l > endLine || l === endLine && c >= endColumn) {\n        break;\n      }\n      index = _encodeGeneratedRanges(ranges, index, writer, state);\n    }\n    if (state[0] < endLine) {\n      catchupLine(writer, state[0], endLine);\n      state[0] = endLine;\n      state[1] = 0;\n    } else {\n      writer.write(comma);\n    }\n    state[1] = encodeInteger(writer, endColumn, state[1]);\n    return index;\n  }\n  function catchupLine(writer, lastLine, line) {\n    do {\n      writer.write(semicolon);\n    } while (++lastLine < line);\n  }\n  function decode(mappings) {\n    const {\n      length\n    } = mappings;\n    const reader = new StringReader(mappings);\n    const decoded = [];\n    let genColumn = 0;\n    let sourcesIndex = 0;\n    let sourceLine = 0;\n    let sourceColumn = 0;\n    let namesIndex = 0;\n    do {\n      const semi = reader.indexOf(';');\n      const line = [];\n      let sorted = true;\n      let lastCol = 0;\n      genColumn = 0;\n      while (reader.pos < semi) {\n        let seg;\n        genColumn = decodeInteger(reader, genColumn);\n        if (genColumn < lastCol) sorted = false;\n        lastCol = genColumn;\n        if (hasMoreVlq(reader, semi)) {\n          sourcesIndex = decodeInteger(reader, sourcesIndex);\n          sourceLine = decodeInteger(reader, sourceLine);\n          sourceColumn = decodeInteger(reader, sourceColumn);\n          if (hasMoreVlq(reader, semi)) {\n            namesIndex = decodeInteger(reader, namesIndex);\n            seg = [genColumn, sourcesIndex, sourceLine, sourceColumn, namesIndex];\n          } else {\n            seg = [genColumn, sourcesIndex, sourceLine, sourceColumn];\n          }\n        } else {\n          seg = [genColumn];\n        }\n        line.push(seg);\n        reader.pos++;\n      }\n      if (!sorted) sort(line);\n      decoded.push(line);\n      reader.pos = semi + 1;\n    } while (reader.pos <= length);\n    return decoded;\n  }\n  function sort(line) {\n    line.sort(sortComparator);\n  }\n  function sortComparator(a, b) {\n    return a[0] - b[0];\n  }\n  function encode(decoded) {\n    const writer = new StringWriter();\n    let sourcesIndex = 0;\n    let sourceLine = 0;\n    let sourceColumn = 0;\n    let namesIndex = 0;\n    for (let i = 0; i < decoded.length; i++) {\n      const line = decoded[i];\n      if (i > 0) writer.write(semicolon);\n      if (line.length === 0) continue;\n      let genColumn = 0;\n      for (let j = 0; j < line.length; j++) {\n        const segment = line[j];\n        if (j > 0) writer.write(comma);\n        genColumn = encodeInteger(writer, segment[0], genColumn);\n        if (segment.length === 1) continue;\n        sourcesIndex = encodeInteger(writer, segment[1], sourcesIndex);\n        sourceLine = encodeInteger(writer, segment[2], sourceLine);\n        sourceColumn = encodeInteger(writer, segment[3], sourceColumn);\n        if (segment.length === 4) continue;\n        namesIndex = encodeInteger(writer, segment[4], namesIndex);\n      }\n    }\n    return writer.flush();\n  }\n  exports.decode = decode;\n  exports.decodeGeneratedRanges = decodeGeneratedRanges;\n  exports.decodeOriginalScopes = decodeOriginalScopes;\n  exports.encode = encode;\n  exports.encodeGeneratedRanges = encodeGeneratedRanges;\n  exports.encodeOriginalScopes = encodeOriginalScopes;\n  Object.defineProperty(exports, '__esModule', {\n    value: true\n  });\n});","map":{"version":3,"names":["comma","charCodeAt","semicolon","chars","intToChar","Uint8Array","charToInt","i","length","c","decodeInteger","reader","relative","value","shift","integer","next","shouldNegate","encodeInteger","builder","num","delta","clamped","write","hasMoreVlq","max","pos","peek","bufLength","td","TextDecoder","Buffer","decode","buf","out","from","buffer","byteOffset","byteLength","toString","String","fromCharCode","StringWriter","constructor","v","flush","subarray","StringReader","indexOf","char","idx","EMPTY","decodeOriginalScopes","input","scopes","stack","line","column","last","pop","kind","fields","hasName","scope","vars","varsIndex","push","encodeOriginalScopes","writer","_encodeOriginalScopes","index","state","startLine","startColumn","endLine","endColumn","l","decodeGeneratedRanges","ranges","genLine","definitionSourcesIndex","definitionScopeIndex","callsiteSourcesIndex","callsiteLine","callsiteColumn","bindingLine","bindingColumn","semi","genColumn","hasDefinition","hasCallsite","hasScope","callsite","bindings","range","defSourcesIndex","isScope","prevCsi","prevLine","sameSource","expressionsCount","expressionRanges","prevBl","expression","encodeGeneratedRanges","_encodeGeneratedRanges","catchupLine","sourcesIndex","scopesIndex","callLine","callColumn","binding","bindingStartLine","bindingStartColumn","expRange","lastLine","mappings","decoded","sourceLine","sourceColumn","namesIndex","sorted","lastCol","seg","sort","sortComparator","a","b","encode","j","segment"],"sources":["C:\\Users\\Mr. Gaurav\\Desktop\\project i\\weather-app\\node_modules\\@jridgewell\\sourcemap-codec\\src\\vlq.ts","C:\\Users\\Mr. Gaurav\\Desktop\\project i\\weather-app\\node_modules\\@jridgewell\\sourcemap-codec\\src\\strings.ts","C:\\Users\\Mr. Gaurav\\Desktop\\project i\\weather-app\\node_modules\\@jridgewell\\sourcemap-codec\\src\\scopes.ts","C:\\Users\\Mr. Gaurav\\Desktop\\project i\\weather-app\\node_modules\\@jridgewell\\sourcemap-codec\\src\\sourcemap-codec.ts"],"sourcesContent":["import type { StringReader, StringWriter } from './strings';\n\nexport const comma = ','.charCodeAt(0);\nexport const semicolon = ';'.charCodeAt(0);\n\nconst chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\nconst intToChar = new Uint8Array(64); // 64 possible chars.\nconst charToInt = new Uint8Array(128); // z is 122 in ASCII\n\nfor (let i = 0; i < chars.length; i++) {\n  const c = chars.charCodeAt(i);\n  intToChar[i] = c;\n  charToInt[c] = i;\n}\n\nexport function decodeInteger(reader: StringReader, relative: number): number {\n  let value = 0;\n  let shift = 0;\n  let integer = 0;\n\n  do {\n    const c = reader.next();\n    integer = charToInt[c];\n    value |= (integer & 31) << shift;\n    shift += 5;\n  } while (integer & 32);\n\n  const shouldNegate = value & 1;\n  value >>>= 1;\n\n  if (shouldNegate) {\n    value = -0x80000000 | -value;\n  }\n\n  return relative + value;\n}\n\nexport function encodeInteger(builder: StringWriter, num: number, relative: number): number {\n  let delta = num - relative;\n\n  delta = delta < 0 ? (-delta << 1) | 1 : delta << 1;\n  do {\n    let clamped = delta & 0b011111;\n    delta >>>= 5;\n    if (delta > 0) clamped |= 0b100000;\n    builder.write(intToChar[clamped]);\n  } while (delta > 0);\n\n  return num;\n}\n\nexport function hasMoreVlq(reader: StringReader, max: number) {\n  if (reader.pos >= max) return false;\n  return reader.peek() !== comma;\n}\n","const bufLength = 1024 * 16;\n\n// Provide a fallback for older environments.\nconst td =\n  typeof TextDecoder !== 'undefined'\n    ? /* #__PURE__ */ new TextDecoder()\n    : typeof Buffer !== 'undefined'\n    ? {\n        decode(buf: Uint8Array): string {\n          const out = Buffer.from(buf.buffer, buf.byteOffset, buf.byteLength);\n          return out.toString();\n        },\n      }\n    : {\n        decode(buf: Uint8Array): string {\n          let out = '';\n          for (let i = 0; i < buf.length; i++) {\n            out += String.fromCharCode(buf[i]);\n          }\n          return out;\n        },\n      };\n\nexport class StringWriter {\n  pos = 0;\n  private out = '';\n  private buffer = new Uint8Array(bufLength);\n\n  write(v: number): void {\n    const { buffer } = this;\n    buffer[this.pos++] = v;\n    if (this.pos === bufLength) {\n      this.out += td.decode(buffer);\n      this.pos = 0;\n    }\n  }\n\n  flush(): string {\n    const { buffer, out, pos } = this;\n    return pos > 0 ? out + td.decode(buffer.subarray(0, pos)) : out;\n  }\n}\n\nexport class StringReader {\n  pos = 0;\n  private declare buffer: string;\n\n  constructor(buffer: string) {\n    this.buffer = buffer;\n  }\n\n  next(): number {\n    return this.buffer.charCodeAt(this.pos++);\n  }\n\n  peek(): number {\n    return this.buffer.charCodeAt(this.pos);\n  }\n\n  indexOf(char: string): number {\n    const { buffer, pos } = this;\n    const idx = buffer.indexOf(char, pos);\n    return idx === -1 ? buffer.length : idx;\n  }\n}\n","import { StringReader, StringWriter } from './strings';\nimport { comma, decodeInteger, encodeInteger, hasMoreVlq, semicolon } from './vlq';\n\nconst EMPTY: any[] = [];\n\ntype Line = number;\ntype Column = number;\ntype Kind = number;\ntype Name = number;\ntype Var = number;\ntype SourcesIndex = number;\ntype ScopesIndex = number;\n\ntype Mix<A, B, O> = (A & O) | (B & O);\n\nexport type OriginalScope = Mix<\n  [Line, Column, Line, Column, Kind],\n  [Line, Column, Line, Column, Kind, Name],\n  { vars: Var[] }\n>;\n\nexport type GeneratedRange = Mix<\n  [Line, Column, Line, Column],\n  [Line, Column, Line, Column, SourcesIndex, ScopesIndex],\n  {\n    callsite: CallSite | null;\n    bindings: Binding[];\n    isScope: boolean;\n  }\n>;\nexport type CallSite = [SourcesIndex, Line, Column];\ntype Binding = BindingExpressionRange[];\nexport type BindingExpressionRange = [Name] | [Name, Line, Column];\n\nexport function decodeOriginalScopes(input: string): OriginalScope[] {\n  const { length } = input;\n  const reader = new StringReader(input);\n  const scopes: OriginalScope[] = [];\n  const stack: OriginalScope[] = [];\n  let line = 0;\n\n  for (; reader.pos < length; reader.pos++) {\n    line = decodeInteger(reader, line);\n    const column = decodeInteger(reader, 0);\n\n    if (!hasMoreVlq(reader, length)) {\n      const last = stack.pop()!;\n      last[2] = line;\n      last[3] = column;\n      continue;\n    }\n\n    const kind = decodeInteger(reader, 0);\n    const fields = decodeInteger(reader, 0);\n    const hasName = fields & 0b0001;\n\n    const scope: OriginalScope = (\n      hasName ? [line, column, 0, 0, kind, decodeInteger(reader, 0)] : [line, column, 0, 0, kind]\n    ) as OriginalScope;\n\n    let vars: Var[] = EMPTY;\n    if (hasMoreVlq(reader, length)) {\n      vars = [];\n      do {\n        const varsIndex = decodeInteger(reader, 0);\n        vars.push(varsIndex);\n      } while (hasMoreVlq(reader, length));\n    }\n    scope.vars = vars;\n\n    scopes.push(scope);\n    stack.push(scope);\n  }\n\n  return scopes;\n}\n\nexport function encodeOriginalScopes(scopes: OriginalScope[]): string {\n  const writer = new StringWriter();\n\n  for (let i = 0; i < scopes.length; ) {\n    i = _encodeOriginalScopes(scopes, i, writer, [0]);\n  }\n\n  return writer.flush();\n}\n\nfunction _encodeOriginalScopes(\n  scopes: OriginalScope[],\n  index: number,\n  writer: StringWriter,\n  state: [\n    number, // GenColumn\n  ],\n): number {\n  const scope = scopes[index];\n  const { 0: startLine, 1: startColumn, 2: endLine, 3: endColumn, 4: kind, vars } = scope;\n\n  if (index > 0) writer.write(comma);\n\n  state[0] = encodeInteger(writer, startLine, state[0]);\n  encodeInteger(writer, startColumn, 0);\n  encodeInteger(writer, kind, 0);\n\n  const fields = scope.length === 6 ? 0b0001 : 0;\n  encodeInteger(writer, fields, 0);\n  if (scope.length === 6) encodeInteger(writer, scope[5], 0);\n\n  for (const v of vars) {\n    encodeInteger(writer, v, 0);\n  }\n\n  for (index++; index < scopes.length; ) {\n    const next = scopes[index];\n    const { 0: l, 1: c } = next;\n    if (l > endLine || (l === endLine && c >= endColumn)) {\n      break;\n    }\n    index = _encodeOriginalScopes(scopes, index, writer, state);\n  }\n\n  writer.write(comma);\n  state[0] = encodeInteger(writer, endLine, state[0]);\n  encodeInteger(writer, endColumn, 0);\n\n  return index;\n}\n\nexport function decodeGeneratedRanges(input: string): GeneratedRange[] {\n  const { length } = input;\n  const reader = new StringReader(input);\n  const ranges: GeneratedRange[] = [];\n  const stack: GeneratedRange[] = [];\n\n  let genLine = 0;\n  let definitionSourcesIndex = 0;\n  let definitionScopeIndex = 0;\n  let callsiteSourcesIndex = 0;\n  let callsiteLine = 0;\n  let callsiteColumn = 0;\n  let bindingLine = 0;\n  let bindingColumn = 0;\n\n  do {\n    const semi = reader.indexOf(';');\n    let genColumn = 0;\n\n    for (; reader.pos < semi; reader.pos++) {\n      genColumn = decodeInteger(reader, genColumn);\n\n      if (!hasMoreVlq(reader, semi)) {\n        const last = stack.pop()!;\n        last[2] = genLine;\n        last[3] = genColumn;\n        continue;\n      }\n\n      const fields = decodeInteger(reader, 0);\n      const hasDefinition = fields & 0b0001;\n      const hasCallsite = fields & 0b0010;\n      const hasScope = fields & 0b0100;\n\n      let callsite: CallSite | null = null;\n      let bindings: Binding[] = EMPTY;\n      let range: GeneratedRange;\n      if (hasDefinition) {\n        const defSourcesIndex = decodeInteger(reader, definitionSourcesIndex);\n        definitionScopeIndex = decodeInteger(\n          reader,\n          definitionSourcesIndex === defSourcesIndex ? definitionScopeIndex : 0,\n        );\n\n        definitionSourcesIndex = defSourcesIndex;\n        range = [genLine, genColumn, 0, 0, defSourcesIndex, definitionScopeIndex] as GeneratedRange;\n      } else {\n        range = [genLine, genColumn, 0, 0] as GeneratedRange;\n      }\n\n      range.isScope = !!hasScope;\n\n      if (hasCallsite) {\n        const prevCsi = callsiteSourcesIndex;\n        const prevLine = callsiteLine;\n        callsiteSourcesIndex = decodeInteger(reader, callsiteSourcesIndex);\n        const sameSource = prevCsi === callsiteSourcesIndex;\n        callsiteLine = decodeInteger(reader, sameSource ? callsiteLine : 0);\n        callsiteColumn = decodeInteger(\n          reader,\n          sameSource && prevLine === callsiteLine ? callsiteColumn : 0,\n        );\n\n        callsite = [callsiteSourcesIndex, callsiteLine, callsiteColumn];\n      }\n      range.callsite = callsite;\n\n      if (hasMoreVlq(reader, semi)) {\n        bindings = [];\n        do {\n          bindingLine = genLine;\n          bindingColumn = genColumn;\n          const expressionsCount = decodeInteger(reader, 0);\n          let expressionRanges: BindingExpressionRange[];\n          if (expressionsCount < -1) {\n            expressionRanges = [[decodeInteger(reader, 0)]];\n            for (let i = -1; i > expressionsCount; i--) {\n              const prevBl = bindingLine;\n              bindingLine = decodeInteger(reader, bindingLine);\n              bindingColumn = decodeInteger(reader, bindingLine === prevBl ? bindingColumn : 0);\n              const expression = decodeInteger(reader, 0);\n              expressionRanges.push([expression, bindingLine, bindingColumn]);\n            }\n          } else {\n            expressionRanges = [[expressionsCount]];\n          }\n          bindings.push(expressionRanges);\n        } while (hasMoreVlq(reader, semi));\n      }\n      range.bindings = bindings;\n\n      ranges.push(range);\n      stack.push(range);\n    }\n\n    genLine++;\n    reader.pos = semi + 1;\n  } while (reader.pos < length);\n\n  return ranges;\n}\n\nexport function encodeGeneratedRanges(ranges: GeneratedRange[]): string {\n  if (ranges.length === 0) return '';\n\n  const writer = new StringWriter();\n\n  for (let i = 0; i < ranges.length; ) {\n    i = _encodeGeneratedRanges(ranges, i, writer, [0, 0, 0, 0, 0, 0, 0]);\n  }\n\n  return writer.flush();\n}\n\nfunction _encodeGeneratedRanges(\n  ranges: GeneratedRange[],\n  index: number,\n  writer: StringWriter,\n  state: [\n    number, // GenLine\n    number, // GenColumn\n    number, // DefSourcesIndex\n    number, // DefScopesIndex\n    number, // CallSourcesIndex\n    number, // CallLine\n    number, // CallColumn\n  ],\n): number {\n  const range = ranges[index];\n  const {\n    0: startLine,\n    1: startColumn,\n    2: endLine,\n    3: endColumn,\n    isScope,\n    callsite,\n    bindings,\n  } = range;\n\n  if (state[0] < startLine) {\n    catchupLine(writer, state[0], startLine);\n    state[0] = startLine;\n    state[1] = 0;\n  } else if (index > 0) {\n    writer.write(comma);\n  }\n\n  state[1] = encodeInteger(writer, range[1], state[1]);\n\n  const fields =\n    (range.length === 6 ? 0b0001 : 0) | (callsite ? 0b0010 : 0) | (isScope ? 0b0100 : 0);\n  encodeInteger(writer, fields, 0);\n\n  if (range.length === 6) {\n    const { 4: sourcesIndex, 5: scopesIndex } = range;\n    if (sourcesIndex !== state[2]) {\n      state[3] = 0;\n    }\n    state[2] = encodeInteger(writer, sourcesIndex, state[2]);\n    state[3] = encodeInteger(writer, scopesIndex, state[3]);\n  }\n\n  if (callsite) {\n    const { 0: sourcesIndex, 1: callLine, 2: callColumn } = range.callsite!;\n    if (sourcesIndex !== state[4]) {\n      state[5] = 0;\n      state[6] = 0;\n    } else if (callLine !== state[5]) {\n      state[6] = 0;\n    }\n    state[4] = encodeInteger(writer, sourcesIndex, state[4]);\n    state[5] = encodeInteger(writer, callLine, state[5]);\n    state[6] = encodeInteger(writer, callColumn, state[6]);\n  }\n\n  if (bindings) {\n    for (const binding of bindings) {\n      if (binding.length > 1) encodeInteger(writer, -binding.length, 0);\n      const expression = binding[0][0];\n      encodeInteger(writer, expression, 0);\n      let bindingStartLine = startLine;\n      let bindingStartColumn = startColumn;\n      for (let i = 1; i < binding.length; i++) {\n        const expRange = binding[i];\n        bindingStartLine = encodeInteger(writer, expRange[1]!, bindingStartLine);\n        bindingStartColumn = encodeInteger(writer, expRange[2]!, bindingStartColumn);\n        encodeInteger(writer, expRange[0]!, 0);\n      }\n    }\n  }\n\n  for (index++; index < ranges.length; ) {\n    const next = ranges[index];\n    const { 0: l, 1: c } = next;\n    if (l > endLine || (l === endLine && c >= endColumn)) {\n      break;\n    }\n    index = _encodeGeneratedRanges(ranges, index, writer, state);\n  }\n\n  if (state[0] < endLine) {\n    catchupLine(writer, state[0], endLine);\n    state[0] = endLine;\n    state[1] = 0;\n  } else {\n    writer.write(comma);\n  }\n  state[1] = encodeInteger(writer, endColumn, state[1]);\n\n  return index;\n}\n\nfunction catchupLine(writer: StringWriter, lastLine: number, line: number) {\n  do {\n    writer.write(semicolon);\n  } while (++lastLine < line);\n}\n","import { comma, decodeInteger, encodeInteger, hasMoreVlq, semicolon } from './vlq';\nimport { StringWriter, StringReader } from './strings';\n\nexport {\n  decodeOriginalScopes,\n  encodeOriginalScopes,\n  decodeGeneratedRanges,\n  encodeGeneratedRanges,\n} from './scopes';\nexport type { OriginalScope, GeneratedRange, CallSite, BindingExpressionRange } from './scopes';\n\nexport type SourceMapSegment =\n  | [number]\n  | [number, number, number, number]\n  | [number, number, number, number, number];\nexport type SourceMapLine = SourceMapSegment[];\nexport type SourceMapMappings = SourceMapLine[];\n\nexport function decode(mappings: string): SourceMapMappings {\n  const { length } = mappings;\n  const reader = new StringReader(mappings);\n  const decoded: SourceMapMappings = [];\n  let genColumn = 0;\n  let sourcesIndex = 0;\n  let sourceLine = 0;\n  let sourceColumn = 0;\n  let namesIndex = 0;\n\n  do {\n    const semi = reader.indexOf(';');\n    const line: SourceMapLine = [];\n    let sorted = true;\n    let lastCol = 0;\n    genColumn = 0;\n\n    while (reader.pos < semi) {\n      let seg: SourceMapSegment;\n\n      genColumn = decodeInteger(reader, genColumn);\n      if (genColumn < lastCol) sorted = false;\n      lastCol = genColumn;\n\n      if (hasMoreVlq(reader, semi)) {\n        sourcesIndex = decodeInteger(reader, sourcesIndex);\n        sourceLine = decodeInteger(reader, sourceLine);\n        sourceColumn = decodeInteger(reader, sourceColumn);\n\n        if (hasMoreVlq(reader, semi)) {\n          namesIndex = decodeInteger(reader, namesIndex);\n          seg = [genColumn, sourcesIndex, sourceLine, sourceColumn, namesIndex];\n        } else {\n          seg = [genColumn, sourcesIndex, sourceLine, sourceColumn];\n        }\n      } else {\n        seg = [genColumn];\n      }\n\n      line.push(seg);\n      reader.pos++;\n    }\n\n    if (!sorted) sort(line);\n    decoded.push(line);\n    reader.pos = semi + 1;\n  } while (reader.pos <= length);\n\n  return decoded;\n}\n\nfunction sort(line: SourceMapSegment[]) {\n  line.sort(sortComparator);\n}\n\nfunction sortComparator(a: SourceMapSegment, b: SourceMapSegment): number {\n  return a[0] - b[0];\n}\n\nexport function encode(decoded: SourceMapMappings): string;\nexport function encode(decoded: Readonly<SourceMapMappings>): string;\nexport function encode(decoded: Readonly<SourceMapMappings>): string {\n  const writer = new StringWriter();\n  let sourcesIndex = 0;\n  let sourceLine = 0;\n  let sourceColumn = 0;\n  let namesIndex = 0;\n\n  for (let i = 0; i < decoded.length; i++) {\n    const line = decoded[i];\n    if (i > 0) writer.write(semicolon);\n    if (line.length === 0) continue;\n\n    let genColumn = 0;\n\n    for (let j = 0; j < line.length; j++) {\n      const segment = line[j];\n      if (j > 0) writer.write(comma);\n\n      genColumn = encodeInteger(writer, segment[0], genColumn);\n\n      if (segment.length === 1) continue;\n      sourcesIndex = encodeInteger(writer, segment[1], sourcesIndex);\n      sourceLine = encodeInteger(writer, segment[2], sourceLine);\n      sourceColumn = encodeInteger(writer, segment[3], sourceColumn);\n\n      if (segment.length === 4) continue;\n      namesIndex = encodeInteger(writer, segment[4], namesIndex);\n    }\n  }\n\n  return writer.flush();\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}